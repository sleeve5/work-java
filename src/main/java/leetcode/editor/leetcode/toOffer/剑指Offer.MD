# 剑指Offer - LCR 120-128 题解整理

## 日期：2026年2月12日

---

## 📚 题目分类总览

| 数据结构/算法 | 题目 | 难度 |
|--------------|------|------|
| 数组 | LCR 120 - 寻找文件副本 | 简单 |
| 数组 | LCR 121 - 寻找目标值 - 二维数组 | 中等 |
| 栈与队列 | LCR 125 - 图书整理 II | 简单 |
| 动态规划 | LCR 126 - 斐波那契数 | 简单 |
| 动态规划 | LCR 127 - 跳跃训练 | 简单 |
| 二分查找 | LCR 128 - 库存管理 I | 简单 |

---

## 一、数组问题

### LCR 120 - 寻找文件副本

#### 题目描述

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，请找出数组中任意一个重复的数字。

#### 整理方法

**方法1：暴力搜索（不推荐）**

- 时间复杂度：O(n²)
- 空间复杂度：O(1)
- 缺点：时间复杂度过高

**方法2：HashSet（推荐）**

- 时间复杂度：O(n)
- 空间复杂度：O(n)
- 优点：实现简单，效率较高

**方法3：原地交换（最优）**

- 时间复杂度：O(n)
- 空间复杂度：O(1)
- 优点：不使用额外空间，效率最高

#### 完整题解

```java
class Solution {
    public int findRepeatDocument(int[] documents) {
        int i = 0;
        while (i < documents.length) {
            // 如果当前元素已经在正确的位置，继续下一个
            if (i == documents[i]) {
                i++;
                continue;
            }
            // 如果发现重复元素，直接返回
            if (documents[i] == documents[documents[i]]) {
                return documents[i];
            }
            // 将元素交换到正确的位置
            int tmp = documents[i];
            documents[i] = documents[documents[i]];
            documents[tmp] = tmp;
        }
        return -1;
    }
}
```

#### 核心思想

利用数组元素值在 0 到 n-1 之间的特点，将每个元素放到与其值相等的索引位置。当遇到冲突时，说明找到了重复元素。

---

### LCR 121 - 寻找目标值 - 二维数组

#### 题目描述

在一个 m x n 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 整理方法

**方法1：暴力搜索（不推荐）**

- 时间复杂度：O(mn)
- 空间复杂度：O(1)
- 缺点：没有利用数组的有序性

**方法2：从右上角开始搜索（推荐）**

- 时间复杂度：O(m+n)
- 空间复杂度：O(1)
- 优点：利用单调性，每次排除一行或一列

**方法3：从左下角开始搜索**

- 时间复杂度：O(m+n)
- 空间复杂度：O(1)
- 优点：与从右上角搜索逻辑类似

#### 完整题解

```java
class Solution {
    public boolean findTargetIn2DPlants(int[][] plants, int target) {
        if (plants.length == 0) {
            return false;
        }
        int m = plants.length - 1, n = plants[0].length - 1;
        int i = 0, j = n;  // 从右上角开始
        
        while (j >= 0 && i <= m) {
            if (plants[i][j] > target) {
                j--;  // 当前元素大于目标，左移
            } else if (plants[i][j] < target) {
                i++;  // 当前元素小于目标，下移
            } else {
                return true;  // 找到目标
            }
        }
        return false;  // 未找到目标
    }
}
```

#### 核心思想

利用矩阵的单调性，从右上角（或左下角）开始搜索：

- 当前元素 > target：目标在左侧，左移一列
- 当前元素 < target：目标在下方，下移一行
- 每次比较可以排除一行或一列

**注意**：不要尝试将二维矩阵一维化用二分查找，除非矩阵是严格连续有序的！

---

## 二、栈与队列

### LCR 125 - 图书整理 II

#### 题目描述

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。

#### 整理方法

**方法：双栈协作（唯一解法）**

- 时间复杂度：
  - appendTail：O(1)
  - deleteHead：O(n) 最坏情况，O(1) 平均情况
- 空间复杂度：O(n)

#### 完整题解

```java
import java.util.Stack;

class CQueue {
    private Stack<Integer> stack1;
    private Stack<Integer> stack2;
    
    public CQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }
    
    public void appendTail(int value) {
        // 直接入栈1
        stack1.push(value);
    }
    
    public int deleteHead() {
        // 如果栈2为空，将栈1的元素全部倒入栈2
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        // 如果栈2仍然为空，说明队列为空
        return stack2.isEmpty() ? -1 : stack2.pop();
    }
}
```

#### 核心思想

- **栈1**：专门用于入队操作
- **栈2**：专门用于出队操作
- 当栈2为空时，将栈1的所有元素倒入栈2，实现队列的"先进先出"特性

**注意**：不要用单个队列直接实现，题目要求必须用栈！

---

## 三、动态规划

### LCR 126 - 斐波那契数

#### 题目描述

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：

- F(0) = 0
- F(1) = 1
- F(N) = F(N-1) + F(N-2)

答案需要取模 1e9+7（1000000007）。

#### 整理方法

**方法1：递归（不推荐）**

- 时间复杂度：O(2ⁿ)
- 空间复杂度：O(n)
- 缺点：重复计算过多，会超时

**方法2：动态规划（推荐）**

- 时间复杂度：O(n)
- 空间复杂度：O(1)
- 优点：效率高，不占用额外空间

#### 完整题解

```java
class Solution {
    public int fib(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        
        int f0 = 0, f1 = 1, fn = 0;
        for (int i = 2; i <= n; i++) {
            fn = (f0 + f1) % 1000000007;
            f0 = f1;
            f1 = fn;
        }
        return f1;
    }
}
```

#### 核心思想

- 保存前两个状态的值，避免重复计算
- 每次计算当前状态后，更新前两个状态
- 每次计算后取模，防止整数溢出

---

### LCR 127 - 跳跃训练

#### 题目描述

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007）。

#### 整理方法

**方法：动态规划（与斐波那契数列相同，但边界不同）**

- 时间复杂度：O(n)
- 空间复杂度：O(1)

#### 完整题解

```java
class Solution {
    public int trainWays(int num) {
        if (num == 0) {
            return 1;  // 不跳也算一种方式
        }
        if (num == 1) {
            return 1;
        }
        
        int a = 0, b = 1, c = 0;
        for (int i = 0; i < num; i++) {
            c = (a + b) % 1000000007;
            a = b;
            b = c;
        }
        return b;
    }
}
```

#### 核心思想

- 跳到第 n 阶的方式数 = 跳到第 n-1 阶的方式数 + 跳到第 n-2 阶的方式数
- 边界条件：num=0 时返回 1（不跳也算一种方式），num=1 时返回 1

**注意**：num=0 时返回 1 而不是 0！

---

## 四、二分查找

### LCR 128 - 库存管理 I

#### 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。

数组元素可能重复。

#### 整理方法

**方法：二分查找（与右边界比较）**

- 时间复杂度：O(log n) 平均，O(n) 最坏（所有元素相同）
- 空间复杂度：O(1)

#### 完整题解

```java
class Solution {
    public int inventoryManagement(int[] stock) {
        int l = 0, r = stock.length - 1;
        
        while (l < r) {
            int m = l + (r - l) / 2;
            
            if (stock[m] > stock[r]) {
                // 最小值在右半部分
                l = m + 1;
            } else if (stock[m] < stock[r]) {
                // 最小值在左半部分（包括m）
                r = m;
            } else {
                // 相等时，缩小右边界
                r--;
            }
        }
        
        return stock[l];
    }
}
```

#### 核心思想

- **与右边界比较**，而不是左边界！
- 当 stock[mid] > stock[right]：最小值在右半部分
- 当 stock[mid] < stock[right]：最小值在左半部分
- 当 stock[mid] == stock[right]：无法判断，缩小右边界

**重要提醒**：

1. ✅ 必须与 stock[right] 比较，不要与 stock[left] 比较！
2. ✅ 使用 l < r 作为循环条件，更简洁
3. ✅ 当 stock[mid] < stock[right] 时，r = m，不是 r = m - 1！

---

## 五、算法与数据结构总结

### 数组操作技巧

| 技巧 | 应用题目 | 说明 |
|------|---------|------|
| 原地交换 | LCR 120 | 利用数组索引与元素值的对应关系 |
| 边角搜索 | LCR 121 | 从右上角或左下角开始，利用单调性 |

### 栈与队列

| 数据结构 | 应用场景 | 核心思想 |
|---------|---------|---------|
| 双栈实现队列 | LCR 125 | 一个栈入队，一个栈出队 |

### 动态规划

| 问题类型 | 核心思想 | 关键变量 |
|---------|---------|---------|
| 斐波那契数列 | F(n) = F(n-1) + F(n-2) | 保存前两个状态 |
| 爬楼梯问题 | 与斐波那契相同，但边界不同 | 注意 num=0 返回 1 |

### 二分查找

| 问题类型 | 比较对象 | 关键点 |
|---------|---------|--------|
| 旋转数组找最小值 | 右边界 | stock[mid] 与 stock[right] 比较 |

---

## 六、常见错误回顾

1. ❌ LCR 120：双重循环时间复杂度过高
2. ❌ LCR 121：尝试将二维矩阵一维化用二分查找
3. ❌ LCR 125：直接用队列实现（题目要求用栈）
4. ❌ LCR 126：递归实现导致超时
5. ❌ LCR 127：num=0 时返回 0 而不是 1
6. ❌ LCR 128：与 stock[left] 比较而不是 stock[right]

---

## 七、学习时间线

- **2026年2月12日**：完成 LCR 120-128 的学习与整理

---

*整理时间：2026年2月12日*
*完成题目：LCR 120、121、125、126、127、128*
